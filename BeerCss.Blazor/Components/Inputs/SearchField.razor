@typeparam TSearchResult
@using Microsoft.AspNetCore.Components.Forms
@using System.Diagnostics.CodeAnalysis
@using BeerCss.Blazor.Common
@using System.Timers;

@code {
    [Parameter, EditorRequired]
    public RenderFragment<TSearchResult> ItemTemplate { get; set; }

    [Parameter, EditorRequired]
    public Func<string?, CancellationToken, Task<IReadOnlyCollection<TSearchResult>>> SearchItems { get; set; }

    [Parameter]
    public TSearchResult? SelectedItem { get; set; }

    [Parameter]
    public EventCallback<TSearchResult> SelectedItemChanged { get; set; }

    [Parameter]
    public Size Size { get; set; } = Size.Medium;

    [Parameter]
    public bool Disabled { get; set; }

    [Parameter]
    public bool FullScreen { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object> AdditionalAttributes { get; set; } = new Dictionary<string, Object>();

    [Parameter]
    public TimeSpan DebounceInterval { get; set; } = TimeSpan.FromMilliseconds(300);

    protected bool InProgress { get; set; }

    private CssBuilder RealCssClass => new CssBuilder()
    .AddClass("field prefix round fill")
    .AddClass(Size.ToCssClass())
    .AddClassFromAttributes(AdditionalAttributes);

    private CssBuilder MenuCss => new CssBuilder()
    .AddClass("max", FullScreen)
    .AddClass("min", !FullScreen);

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (this.Disabled && this.AdditionalAttributes is null)
        {
            this.AdditionalAttributes = new Dictionary<string, object> { { "disabled", "disabled" } };
        }
        else if (this.Disabled && this.AdditionalAttributes is not null && !this.AdditionalAttributes.ContainsKey("disabled"))
        {
            this.AdditionalAttributes = new Dictionary<string, object>(this.AdditionalAttributes!) { { "disabled", "disabled" } };
        }
        else if (!this.Disabled && this.AdditionalAttributes is not null && this.AdditionalAttributes.ContainsKey("disabled"))
        {
            var attributes = new Dictionary<string, object>(this.AdditionalAttributes!);
            attributes.Remove("disabled");
            this.AdditionalAttributes = attributes;
        }
    }

    protected IReadOnlyCollection<TSearchResult> Results { get; set; } = [];

    private string? criteria;
    private CancellationTokenSource? debounce;

    private async Task OnCriteriaChanged(string? newValue)
    {
        criteria = newValue;
        await (debounce?.CancelAsync() ?? Task.CompletedTask);
        debounce = new();
        
        SelectedItem = default;
        await SelectedItemChanged.InvokeAsync(SelectedItem);

        try
        {
            await Task.Delay(DebounceInterval, debounce.Token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        InProgress = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            Results = await this.SearchItems(newValue, debounce.Token);
        }
        catch (TaskCanceledException)
        {
            return;
        }
        finally
        {
            InProgress = false;
        }

        await InvokeAsync(StateHasChanged);
    }

    private Func<Task> OnSelectedItemChanged(TSearchResult? selected)
        => async () => await SelectedItemChanged.InvokeAsync(selected);
}

<div class="@RealCssClass">
    @if (InProgress)
    {
        <Progress Circle />
    }
    else
    {
        <i class="front">search</i>
    }
    <input type="text" value="@criteria" />
    <menu class="@MenuCss">
        <li>
            <div class="field large prefix">
                <i class="front">arrow_back</i>
                @if (InProgress)
                {
                    <Progress Circle />
                }
                <input type="text" @bind:event="oninput" @bind:get="criteria" @bind:set="@OnCriteriaChanged" />
            </div>
        </li>
        @foreach (var result in Results)
        {
            <li @onmousedown="OnSelectedItemChanged(result)">
                @ItemTemplate(result)
            </li>
        }
    </menu>
</div>